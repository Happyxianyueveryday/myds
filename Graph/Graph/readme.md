  # 图的经典算法

  ## 1. 图的深度优先遍历(dfs)
  图的深度优先遍历一般使用栈进行实现，其算法和树的前序遍历类似，但是需要额外标记各个结点是否已经访问过，因为图中可能存在环。
  
  图的深度优先遍历算法(dfs)的基本步骤如下：
  > 1. 创建一个临时栈，并选择一个遍历的开始结点加入栈中。
  > 2. 创建一个记录数组记录各个结点是否已经访问过，将开始结点标记为已经访问。
  > 3. 循环进行以下步骤直到栈为空为止：
  >> (1) 从栈顶出栈一个结点s  
  >> (2) 通过记录数组判断结点s是否已经访问过，若未访问过，则输出该结点，然后在记录数组中标记该结点为已访问；若已经访问过，则直接跳回循环开始处(continue语句)  
  >> (3) 将结点s的所有未访问过的邻居结点依次入栈  
  
  ## 2. 图的广度优先遍历(bfs)
  图的广度优先遍历一般使用队列进行实现，其算法和树的层次遍历类似，但是需要额外标记各个结点是否已经访问过，因为图中可能存在环。
  
  图的广度优先遍历算法(bfs)的基本步骤如下:
  > 1. 创建一个临时队列，将遍历的起始结点入队
  > 2. 创建一个记录数组记录各个结点是否已经访问过，将开始结点标记为已经访问。
  > 3. 循环进行以下步骤直到队列为空为止:
  >> (1) 从队首出队一个结点  
  >> (2) 判断该结点是否已经访问过，若未访问过，则输出该结点，然后在记录数组中标记该结点为已访问；若已经访问过，则直接跳回循环开始处(continue语句)   
  >> (3) 将该结点的所有未访问过的邻居结点加入队列尾部  

  ## 3. 图的结点间最短路径
  图的结点间最短路径问题，主要存在两种主要算法：dijkstra算法和floyd算法。
  
  ### 3.1 dijkstra算法
  
  dijkstra算法是一种贪心算法，主要实现步骤如下。
  
  > 1. 创建两个集合S和N，集合S初始时仅包含起点结点start，集合N则包含图中的所有其他结点。  
  > 2. 初始化集合N中的每一个结点（记为结点i）通过集合S中的结点到达起点start的距离dist\[i]，若结点i是结点start的邻居结点，则dist\[i]就是结点i和结点start间的距离，否则初始化dist\[i]为无穷大。  
  > 3. 循环进行以下步骤直到集合N为空为止:   
  >> (1) 从集合N中选取到起始结点start的距离dist最短的结点u   
  >> (2) 将结点u从集合N中删除，并加入集合S  
  >> (3) 由于这时多了一个结点u可供经过，因此更新集合N中剩下的各个结点v到起点start的距离dist\[v]，更新公式为: dist\[v]=min(dist\[v], c(v,u)+dist\[u])
  
  
  ## 3.2 floyd算法
  floyd算法相对于dijkstra算法实现起来更为简洁，但是时间复杂度较高，为O(n^3)。
  
  floyd算法的核心思想是在原来的邻接表的基础上进行迭代和更新，可以用如下的公式进行表示：
  
  ```
  data[i][j]=min(data[i][j], data[i][m]+data[m][j])
  ```
  
  
  # 4. 图的最小生成树
  
  图的最小生成树问题主要求解算法有两种——prim算法和kruskkal算法。其中prim算法是基于结点进行构造的算法，kruskkal算法是基于边进行构造的算法。
  
  ## 4.1 prim算法
  prim算法是基于图的结点来进行构造最小生成树的算法。简言之，该算法每次选择距离当前所构造的生成树中的结点集合S最小的一个结点加入最小生成树中，并将对应的边也加入最小生成树中。
  
  具体而言， prim算法的具体实现步骤如下：
  > 1. 初始化两个集合S和N，其中集合S包含图中的任一结点v，集合N包含图中的其他结点。
  > 2. 初始化集合N中所含结点u到集合S的距离，集合N中的结点u到集合S的距离dist\[u]定义为结点u到集合S中的各个结点的距离的最小值。
  > 3. 循环进行以下步骤，直到所有结点都已经加入集合S中时停止: 
  >> (1) 从集合N中选取一个到集合S距离dist\[m]最近的结点m，假设最近距离的边为m-n，其中n为集合S中的结点  
  >> (2) 将结点m从集合N中删除并加入集合S，并将对应的边m-n加入最小生成树  
  >> (3) 由于集合S中新加入了一个结点m，故更新集合N中剩下的各个结点u到集合S的距离，更新公式为: dist\[u]=min(dist\[u], d(u, m))，其中d(u,m)为结点u和结点m之间的距离    
  
  
  ## 4.2 kruskkal算法
  kruskkal算法是基于图的边构造最小生成树的算法。简言之，kruskkal算法首先将原图中的各个边从小到大排序，然后依次将边长最小的，且加入最小生成树后不会产生环的，并且尚未加入最小生成树的边加入最小生成树，直到最小生成树中已经含有(n-1)条边(其中n为图的结点数量)时停止。
  
  具体而言，kruskkal算法的具体实现步骤如下所示。
  > 1. 初始化两个集合S和N，集合S为空集，集合N包含原图中的所有的边
  > 2. 将集合N中的边从小到大排序
  > 3. 因为集合N是有序的，因此从前向后遍历集合N中的每一条边，并进行以下步骤，直到集合S中含有(n-1)条边时停止(其中n为原图中的结点数量)：
  >> (1) 若当前边加入集合S后，集合S所表示的最小生成树中不会产生环，就将该边从集合N中删除，并加入集合S  
  >> (2) 若当前边加入集合S后产生环，则忽略该条边，回到循环步骤处理下一条边(continue语句)  
  
  需要补充的是: 在kruskkal算法中，需要判断一个图是否有环，判断一个图是否存在环的算法非常朴素，对该图从每一个结点开始进行深度优先遍历(dfs)或者广度优先遍历(bfs)，只要在遍历过程中遇到了之前已经访问过的结点，则该图中必然存在环。
  

